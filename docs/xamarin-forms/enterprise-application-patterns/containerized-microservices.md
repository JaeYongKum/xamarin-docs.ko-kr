---
title: 컨테이너화된 마이크로 서비스
description: 이 장에서 마이크로 서비스 및 컨테이너 민첩 하 고 확장 가능한 빌드를 사용 하는 방법 및 신뢰할 수 있는 최신 클라우드 응용 프로그램을 설명 합니다.
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 33be84bc17f72c8b70d117a0742b001f1f763d3d
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61300760"
---
# <a name="containerized-microservices"></a>컨테이너화된 마이크로 서비스

각 계층에서 특정 기술을 사용 하는 계층화 된 응용 프로그램 개발에 초점을 맞춰 클라이언트-서버 응용 프로그램을 개발 되었습니다. 이러한 응용 프로그램은 라고도 *모놀리식* 되며 응용 프로그램 패키지를 미리 최대 로드에 대 한 크기를 조정 하는 하드웨어입니다. 이러한 개발 방식의 주요 단점은 테스트 비용과 개별 구성 요소는 쉽게 확장할 수 없습니다, 각 계층 내의 구성 요소 간의 긴밀 한 결합 됩니다. 간단한 업데이트를 가질 수 있습니다 계층의 나머지 부분에 예기치 못한 결과가 이므로 응용 프로그램 구성 요소에 대 한 변경 다시 테스트 하 고 다시 배포 하는 전체 계층에 필요 합니다.

특히 우려되 클라우드 시대의 확장 개별 구성 요소는 쉽게 사용할 수 없습니다. 모놀리식 응용 프로그램 도메인 특정 기능을 포함 하 고 일반적으로 프런트 엔드, 비즈니스 논리 및 데이터 저장소 등의 기능 계층으로 나뉩니다. 그림 8-1에서와 같이 여러 컴퓨터에 전체 응용 프로그램을 복제 하 여 모놀리식 응용 프로그램 크기가 조정 됩니다.

![](containerized-microservices-images/monolithicapp.png "모놀리식 응용 프로그램 크기 조정 방법")

**그림 8-1**: 모놀리식 응용 프로그램 크기 조정 방법

## <a name="microservices"></a>마이크로 서비스

마이크로 서비스 응용 프로그램 개발 및 배포 하는 다른 방법을, 민첩성, 확장성 및 안정성 요구 사항을 최신 클라우드 응용 프로그램에 적합 한 방법을 제공 합니다. 응용 프로그램의 전체 기능을 제공 하기 위해 함께 작동 하는 독립 구성 요소는 마이크로 서비스 응용 프로그램 분해 됩니다. 응용 프로그램 구성 되어야 서비스 소규모 독립 문제를 반영 하도록 각 마이크로 서비스는 단일 함수를 구현 하는 용어 마이크로 서비스를 강조 합니다. 또한 각 마이크로 서비스는 잘 정의 된 계약에 다른 마이크로 서비스에서 통신 하 고 데이터를 공유할 수 있도록 합니다. 쇼핑 카트를 포함 하 고 처리를 재고, 하위 시스템 및 지불 처리를 구매 하는 마이크로 서비스의 일반적인 예입니다.

마이크로 서비스 규모를 확장할 독립적으로 확장할 giant 모놀리식 응용 프로그램을 비교 하 여 합니다. 즉, 불필요 하 게 확장 응용 프로그램의 다른 영역 대신 더 많은 처리 전원 또는 네트워크 대역폭 수요를 지 원하는 데 필요한 특정 기능 영역을를 확장할 수 있습니다. 그림 8-2는 마이크로 서비스가 배포 되 고 독립적으로 확장,이 이렇게 컴퓨터에서 서비스의 인스턴스를 만드는 합니다.

![](containerized-microservices-images/microservicesapp.png "마이크로 서비스 응용 프로그램 크기 조정 방법")

**그림 8-2**: 마이크로 서비스 응용 프로그램 크기 조정 방법

마이크로 서비스 규모는 거의 즉시 로드 변화에 맞게 응용 프로그램 허용 될 수 있습니다. 예를 들어, 단일 마이크로 서비스 응용 프로그램의 웹 지향 기능에만 추가 들어오는 트래픽을 처리 하도록 확장 해야 하는 응용 프로그램에서 마이크로 서비스를 수 있습니다.

응용 프로그램 확장성을 위해 클래식 모델은 영구 데이터를 저장할 공유 외부 데이터 저장소를 사용 하 여 부하 분산, 상태 비저장 계층을 것입니다. 상태 저장 마이크로 서비스는 일반적으로 배치 된 서버에 로컬로 저장 하는 자체 영구 데이터를 관리, 네트워크 오버 헤드를 방지 하려면 액세스 및 복잡성을 교차 서비스 작업입니다. 이 데이터의 가능한 가장 빠른 처리를 사용 하도록 설정 하 고 캐싱 시스템에 대 한 필요성을 제거할 수 있습니다. 또한 확장 가능한 상태 저장 마이크로 서비스는 일반적으로 단일 서버가 지원할 수 초과 데이터 크기 및 전송 처리량을 관리 하는 인스턴스 간에 데이터를 분할 합니다.

마이크로 서비스는 또한 독립적인 업데이트를 지원합니다. 마이크로 서비스 간에 느슨한 결합을 신속 하 고 신뢰할 수 있는 응용 프로그램 혁신을 제공합니다. 해당 독립 분산된 특성 인스턴스의 단일 마이크로 서비스의 하위 집합만 지정된 된 시간에 업데이트 됩니다 여기서 롤링 업데이트를 지원 합니다. 따라서 문제가 감지 되 면 버그가 있는 업데이트 수 롤백할 수 잘못 된 코드 또는 구성으로 모든 인스턴스가 업데이트 전에 합니다. 마찬가지로, 마이크로 서비스 일반적으로 사용 하 여 스키마 버전 관리 업데이트 내용이 적용 되는 마이크로 서비스에 관계 없이 인스턴스에 중인 통신할 때 클라이언트에 일관 된 버전을 볼 수 있도록 합니다.

따라서 마이크로 서비스 응용 프로그램에 다양 한 이점을 통해 모놀리식 응용 프로그램

-   각 마이크로 서비스는 비교적 작은 쉽게 관리 및 발전입니다.
-   각 마이크로 서비스를 개발 하 고 다른 서비스와 독립적으로 배포할 수 있습니다.
-   각 마이크로 서비스 수 수평 독립적으로 합니다. 예를 들어 카탈로그 서비스 또는 장바구니 서비스 쇼핑 이어야 할 수도 있습니다 스케일 아웃 하는 주문 서비스가 둘 이상의 합니다. 따라서 결과 인프라 규모 확장 시 리소스를 보다 효율적으로 사용 됩니다.
-   각 마이크로 서비스는 모든 문제를 격리합니다. 예를 들어, 서비스에 문제가 있는 경우만 해당 서비스를 영향입니다. 다른 서비스 계속 요청을 처리할 수 있습니다.
-   각 마이크로 서비스는 최신 기술을 사용할 수 있습니다. 마이크로 서비스 자치 및 실행 하 여 나란히 이기 때문에 최신 기술과 프레임 워크 용도, 모놀리식 응용 프로그램에서 사용할 수 있는 이전 프레임 워크를 사용 하는 대신 합니다.

그러나 마이크로 서비스 기반 솔루션에 잠재적인 단점이 있습니다.

-   응용 프로그램을 마이크로 서비스로 분할 하는 방법을 선택이 각 마이크로 서비스는 완전히 자율적, 해당 데이터 원본에 대 한 책임을 포함 하 여 종단 간으로 어려울 수 있습니다.
-   개발자는 응용 프로그램 복잡성 및 대기 시간을 추가 하는 서비스 간 통신을 구현 해야 합니다.
-   일반적으로 여러 마이크로 서비스 간 원자성 트랜잭션을 사용할 수 없습니다. 따라서 비즈니스 요구 사항 마이크로 서비스 간의 최종 일관성을 적용 해야 합니다.
-   프로덕션 환경에 배포 하 고 여러 독립적인 서비스의 손상 된 시스템 관리에 운영 복잡성이 있습니다.
-   클라이언트-마이크로 서비스 간 직접 통신의 마이크로 서비스의 계약 어려울 수 있습니다. 예를 들어, 시간이 지남에 따라 시스템 서비스에 분할 하는 방법을 변경 해야 할 수 있습니다. 단일 서비스 두 개 이상의 서비스로 분할할 수 하 고 두 서비스를 병합할 수 있습니다. 마이크로 서비스와 직접 통신 하는 클라이언트를이 리팩터링 작업에는 클라이언트 앱과 호환성이 깨질 수 있습니다.

## <a name="containerization"></a>컨테이너화

컨테이너 화 되는 응용 프로그램 및 종속성 외에 배포 매니페스트 파일로 추상화 환경 구성을 해당 버전이 지정 된 집합 함께 하나의 단위로 테스트 컨테이너 이미지로 패키지 되는 소프트웨어 개발 방법 및 호스트 운영 체제를 배포 합니다.

컨테이너는 격리 된, 리소스 제어 되며 이식 가능한 운영 환경을 다른 컨테이너 호스트의 리소스를 변경 하지 않고도 응용 프로그램 실행할 수 있습니다. 따라서 컨테이너를 찾아 새로 설치 된 물리적 컴퓨터 또는 가상 컴퓨터 처럼 작동 합니다.

그림 8-3에서와 같이 컨테이너와 가상 컴퓨터 간의 많은 유사점이 있습니다.

![](containerized-microservices-images/containersvsvirtualmachines.png "마이크로 서비스 응용 프로그램 크기 조정 방법")

**그림 8-3**: Virtual machines 및 컨테이너의 비교

컨테이너 운영 체제를 실행 하 고 파일 시스템에 물리적 또는 가상 머신 처럼 네트워크를 통해 액세스할 수 있습니다. 그러나 기술 및 컨테이너에서 사용 하는 개념에는 virtual machines에서 매우 다릅니다. 가상 컴퓨터 응용 프로그램, 필수 종속성을 및 전체 게스트 운영 체제를 포함 합니다. 컨테이너 응용 프로그램 및 해당 종속성을 포함 하지만 다른 컨테이너와 Hyper-v 컨테이너 컨테이너 당 특수 가상 컴퓨터 안에서 실행) (별도 호스트 운영 체제에서 격리 된 프로세스로 실행을 사용 하 여 운영 체제를 공유 합니다. 따라서 컨테이너 리소스를 공유 하 고 일반적으로 가상 컴퓨터 보다 더 적은 리소스가 필요 합니다.

컨테이너 기반 개발 및 배포 방법의 장점은 일관 되지 않은 환경 설정으로 인 한 문제를 발생 하는 문제를 대부분 제거 한다는 점입니다. 또한 컨테이너는 필요에 따라 새 컨테이너 인스턴스 만들기에서 빠른 응용 프로그램 확장 기능을 허용 합니다.

주요 개념을 만들고 컨테이너를 사용 하는 경우 다음과 같습니다.

-   컨테이너 호스트: 물리적 컴퓨터 또는 가상 컴퓨터 호스트 컨테이너를 구성 합니다. 컨테이너 호스트는 하나 이상의 컨테이너를 실행 합니다.
-   컨테이너 이미지: 이미지 서로 위에 쌓입니다 계층화 된 파일 시스템의 공용 구조체의 구성 및는 컨테이너의 기초입니다. 이미지 상태 없고 다른 환경으로 배포 되는 변경 되지 않습니다.
-   컨테이너: 컨테이너는 이미지의 런타임 인스턴스입니다.
-   컨테이너 OS 이미지: 컨테이너는 이미지에서 배포 됩니다. 컨테이너 운영 체제 이미지는 컨테이너를 구성 하는 잠재적으로 많은 이미지 계층에서 첫 번째 계층입니다. 컨테이너는 운영 체제를 변경할 수 이며 수정할 수 없습니다.
-   컨테이너 리포지토리: 컨테이너 이미지를 만들 때마다 이미지 및 해당 종속성은 로컬 저장소에 저장 됩니다. 이러한 이미지는 컨테이너 호스트에서 여러 번 재사용할 수 있습니다. 컨테이너 이미지를 저장할 수도 있습니다는 공용 또는 개인 레지스트리를에서 같은 [Docker 허브](https://hub.docker.com/)다른 컨테이너 호스트에서 사용할 수 있도록 합니다.

기업 도입을 확대 컨테이너 기반 응용 프로그램과 마이크로 서비스를 구현 하 고 Docker는 대부분의 소프트웨어 플랫폼 및 클라우드 공급 업체에서 채택 하는 표준 컨테이너 구현을 성장 했습니다.

EShopOnContainers 참조 응용 프로그램 그림 8-4와 같이 4 개의 컨테이너 화 된 백 엔드 마이크로 서비스를 호스트에 Docker를 사용 합니다.

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers 참조 응용 프로그램 백 엔드 마이크로 서비스")

**그림 8-4**: eShopOnContainers 참조 응용 프로그램 백 엔드 마이크로 서비스

참조 응용 프로그램의 백 엔드 서비스의 아키텍처는 공동 마이크로 서비스 및 컨테이너의 형태로 여러 자치 하위 시스템으로 분해 됩니다. 단일 영역 기능을 제공 하는 각 마이크로 서비스: id 서비스, 카탈로그 서비스, 정렬 하는 서비스 및 장바구니 서비스입니다.

각 마이크로 서비스에 자체 데이터베이스가 있어 다른 마이크로 서비스에서 완전히 분리 될 수 있습니다. 필요한 경우 다른 마이크로 서비스에서 데이터베이스 간의 일관성 응용 프로그램 수준 이벤트를 사용 하 여 이루어집니다. 자세한 내용은 [마이크로 서비스 간의 통신](#communication_between_microservices)합니다.

참조 응용 프로그램에 대 한 자세한 내용은 참조 하세요. [.NET 마이크로 서비스: 컨테이너화된 .NET 애플리케이션을 위한 아키텍처](https://aka.ms/microservicesebook)를 참조하세요.

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>마이크로 서비스와 클라이언트 간 통신

EShopOnContainers 모바일 앱 백 엔드의 컨테이너 화 된 마이크로 서비스를 사용 하 여 통신 *클라이언트-마이크로 서비스를 직접* 그림 8-5와 같이 통신 합니다.

![](containerized-microservices-images/directclienttomicroservicecommunication.png "마이크로 서비스 응용 프로그램 크기 조정 방법")

**그림 8-5**: 클라이언트-마이크로 서비스 간 직접 통신

클라이언트-마이크로 서비스 간 직접 통신을 사용 하 여 모바일 앱에서는 요청을 마이크로 서비스 마다 다른 TCP 포트를 사용 하 여 해당 공용 엔드포인트를 통해 직접 각 마이크로 서비스. 프로덕션 환경에서 끝점은 일반적으로 매핑할 사용 가능한 인스턴스 요청을 분산 하는 마이크로 서비스의 부하 분산 장치.

> [!TIP]
> API 게이트웨이 통신을 사용 하는 것이 좋습니다. 클라이언트-마이크로 서비스 간 직접 통신 기반 응용 프로그램에서 대규모 또는 복잡 한 마이크로 서비스 구축 이지만 더 작은 응용 프로그램에 적합 하면 단점이 있을 수 있습니다. 대규모 마이크로 서비스 설계 수십 개의 마이크로 서비스를 사용 하 여 응용 프로그램을 기반 하는 경우, API 게이트웨이 통신을 사용 하는 것이 좋습니다. 자세한 내용은 참조 하세요. [.NET 마이크로 서비스: 컨테이너화된 .NET 애플리케이션을 위한 아키텍처](https://aka.ms/microservicesebook)를 참조하세요.

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>마이크로 서비스 간 통신

마이크로 서비스 기반 응용 프로그램을 분산된 시스템에서는 잠재적으로 여러 컴퓨터에서 실행 됩니다. 각 서비스 인스턴스는 일반적으로 프로세스입니다. 따라서 서비스는 HTTP, TCP, 메시지 큐 프로토콜 AMQP (Advanced)에서 또는 각 서비스의 성격에 따라 이진 프로토콜과 같은 프로세스 간 통신 프로토콜을 사용 하 여 작용 해야 합니다.

마이크로 서비스-마이크로 서비스 간 통신에 대 한 두 가지 일반적인 방법은 데이터 및 업데이트를 여러 마이크로 서비스 간에 통신 하는 경우 간단한 비동기 메시징에 대 한 쿼리 하는 경우 HTTP 기반 REST 통신 됩니다.

비동기 메시징 기반된 이벤트 기반 통신은 여러 마이크로 서비스 간에 변경 내용을 전파할 때 중요 합니다. 이 방법을 사용 하 여 마이크로 서비스 경우 주목할 만한 발생 하는, 예를 들어 비즈니스 엔터티를 업데이트할 때 이벤트를 게시 합니다. 다른 마이크로 서비스는 이러한 이벤트를 구독합니다. 그런 다음 이벤트를 수신 하는 마이크로 서비스는 자체 비즈니스 엔터티를 다시 게시 되 고 더 많은 이벤트가 발생할 수 있습니다 업데이트 됩니다. 이 게시-구독 기능 이벤트 버스를 사용 하 여 일반적으로 이루어집니다.

이벤트 버스 게시-구독 그림 8-6에서와 같이 명시적으로 서로 인식 되도록 구성 요소를 요구 하지 않고 마이크로 서비스 간 통신을 허용 합니다.

![](containerized-microservices-images/eventbus.png "이벤트 버스를 사용 하 여 게시-구독")

**그림 8-6:** 이벤트 버스를 사용 하 여 게시-구독

응용 프로그램 관점에서 이벤트 버스는 단순히 게시-구독 채널 인터페이스를 통해 노출 합니다. 그러나 이벤트 버스 구현 되는 방식 달라질 수 있습니다. 예를 들어, RabbitMQ, Azure Service Bus, NServiceBus MassTransit 등 다른 서비스 버스 이벤트 버스 구현을 사용할 수 있습니다. 그림 8-7 eShopOnContainers 참조 응용 프로그램에서 이벤트 버스는 사용 하는 방법을 보여 줍니다.

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "참조 응용 프로그램에서 비동기 이벤트 기반 통신")

**그림 8-7:** 참조 응용 프로그램에서 비동기 이벤트 기반 통신

RabbitMQ를 사용 하 여 구현 하는 eShopOnContainers 이벤트 버스에 일 대 다 비동기 게시-구독 기능을 제공 합니다. 이 이벤트를 게시 한 후 있어야 하는 여러 구독자가 동일한 이벤트에 대 한 수신 의미 합니다. 그림 8-9에서는이 관계를 보여 줍니다.

![](containerized-microservices-images/eventdrivencommunication.png "일대다 통신")

**그림 8-9**: 일대다 통신

이벤트를 사용 하 여 서비스 간의 최종 일관성을 유지 하는 여러 서비스에 걸쳐 있는 비즈니스 트랜잭션을 구현 하는이-일대다 통신 방법입니다. 결과적으로 일관 된 트랜잭션이 있는 일련의 분산된 단계로 이루어져 있습니다. 따라서 사용자 프로필 마이크로 서비스 하기 위한 명령을 받으면 해당 데이터베이스에 사용자의 세부 정보를 업데이트 하 고 UserUpdated 이벤트를 이벤트 버스에 게시 합니다. 이 이벤트를 받고 응답에서 각각의 데이터베이스에서 구매자 정보를 업데이트할 장바구니 마이크로 서비스와 주문 마이크로 서비스 구독입니다.

> [!NOTE]
> RabbitMQ를 사용 하 여 구현 하는 eShopOnContainers 이벤트 버스 개념 증명 으로만 사용할 것입니다. 프로덕션 시스템에 대 한 대체 이벤트 버스 구현은 고려해 야 합니다.

이벤트 버스 구현에 대 한 자세한 내용은 [.NET 마이크로 서비스: 컨테이너화된 .NET 애플리케이션을 위한 아키텍처](https://aka.ms/microservicesebook)를 참조하세요.

## <a name="summary"></a>요약

마이크로 서비스 응용 프로그램 개발 및 배포는 최신 클라우드 응용 프로그램의 민첩성, 확장성 및 안정성 요구 사항에 적합 한 방법을 제공 합니다. 이러한 수 있는 스케일 아웃 독립적으로 즉,는 특정 기능 영역의 크기를 조정할 수 더 많은 처리 전원 또는 네트워크 대역폭을 불필요 하 게 영역의 크기 조정 없이 요청을 지원 해야 하는 마이크로 서비스의 주요 장점 중 하나는 증가 되는 수요에 발생 하는 응용 프로그램입니다.

컨테이너는 격리 된, 리소스 제어 되며 이식 가능한 운영 환경을 다른 컨테이너 호스트의 리소스를 변경 하지 않고도 응용 프로그램 실행할 수 있습니다. 기업 도입을 확대 컨테이너 기반 응용 프로그램과 마이크로 서비스를 구현 하 고 Docker는 대부분의 소프트웨어 플랫폼 및 클라우드 공급 업체에서 채택 하는 표준 컨테이너 구현을 성장 했습니다.


## <a name="related-links"></a>관련 링크

- [2mb PDF 전자책 다운로드](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (샘플)](https://github.com/dotnet-architecture/eShopOnContainers)
