---
ms.openlocfilehash: b505f4a4f7a8f50a6044d01a327eef76a7b1ce3b
ms.sourcegitcommit: b0ea451e18504e6267b896732dd26df64ddfa843
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/13/2020
ms.locfileid: "70758043"
---
|속성|설명|옵션|
|--- |--- |--- |
|`abi.type`|**ABI 형식** &ndash; 에뮬레이트된 디바이스의 ABI(애플리케이션 이진 인터페이스) 형식을 지정합니다. **x86** 옵션은 일반적으로 “x86” 또는 “IA-32”라고 하는 명령 집합용입니다. **x86_64** 옵션은 64비트 x86 명령 집합용입니다. **armeabi-v7a** 옵션은 v7-a ARM 확장이 있는 ARM 명령 집합용입니다. **arm64-v8a** 옵션은 AArch64를 지원하는 ARM 명령 집합용입니다.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**캐시 파티션** &ndash; 에뮬레이트된 디바이스에서 디바이스에 대해 **/cache** 파티션을 사용할지 여부를 결정합니다. **/cache** 파티션(처음에는 비어 있음)은 Android에서 자주 액세스하는 데이터 및 앱 구성 요소를 저장하는 위치입니다. **no**로 설정하면 에뮬레이터에서 **/cache** 파티션을 사용하지 않고 다른 `disk.cache` 설정은 무시됩니다.|yes, no|
|`disk.cachePartition.path`|**캐시 파티션 경로** &ndash; 개발 컴퓨터의 캐시 파티션 이미지 파일을 지정합니다. 에뮬레이터에서 이 파일을 **/cache** 파티션에 사용합니다. 에뮬레이터의 데이터 디렉터리의 절대 경로 또는 상대 경로를 입력합니다. 설정되지 않으면 에뮬레이터에서 **cache.img**라는 빈 임시 파일을 개발 컴퓨터에 만듭니다. 파일이 없으면 빈 파일로 만들어집니다. `disk.cachePartition`이 **no**로 설정된 경우 이 옵션은 무시됩니다.||
|`disk.cachePartition.size`|**캐시 파티션 크기** &ndash; 캐시 파티션 파일의 크기(바이트 단위)입니다. 앱에서 기본 캐시 크기인 66메가바이트를 초과하는 매우 큰 파일을 다운로드하지 않으면 이 옵션은 일반적으로 설정할 필요가 없습니다. `disk.cachePartition`이 **no**로 설정된 경우 이 옵션은 무시됩니다. 이 값이 정수이면 크기를 바이트 단위로 지정합니다. 값에 **K**, **M** 또는 **G**를 추가하여 크기를 킬로바이트, 메가바이트 및 기가바이트 단위로 지정할 수도 있습니다. 최소 크기는 **9M**이고, 최대 크기는 **1,023G**입니다.||
|`disk.dataPartition.initPath`|**데이터 파티션 초기 경로** &ndash; 데이터 파티션의 초기 콘텐츠를 지정합니다. 사용자 데이터를 제거한 후에 에뮬레이터에서 **userdata.img**를 초기 버전으로 사용하는 대신 지정된 파일의 내용을 사용자 데이터(기본적으로 **userdata-qemu.img**)로 복사합니다.||
|`disk.dataPartition.path`|**데이터 파티션 경로** &ndash; 사용자 데이터 파티션 파일을 지정합니다. 영구 사용자 데이터 파일을 구성하려면 개발 컴퓨터에 파일 이름과 경로를 입력합니다. 파일이 없으면 에뮬레이터에서 **userdata.img** 기본 파일로부터 이미지를 만들고, `disk.dataPartition.path`로 지정된 파일 이름으로 저장하고, 에뮬레이터가 종료될 때 사용자 데이터를 계속 유지합니다. 경로를 지정하지 않으면 기본 파일 이름은 **userdata-qemu.img**입니다. **\<temp>** 특수 값을 사용하면 에뮬레이터에서 임시 파일을 만들고 사용할 수 있습니다. `disk.dataPartition.initPath`가 설정된 경우 부팅 시 해당 콘텐츠가 `disk.dataPartition.path` 파일로 복사됩니다. 이 옵션은 비워 둘 수 없습니다.||
|`disk.dataPartition.size`|**데이터 파티션 크기** &ndash; 사용자 데이터 파티션의 크기(바이트 단위)를 지정합니다. 이 값이 정수이면 크기를 바이트 단위로 지정합니다. 값에 **K**, **M** 또는 **G**를 추가하여 크기를 킬로바이트, 메가바이트 및 기가바이트 단위로 지정할 수도 있습니다. 최소 크기는 **9M**이고, 최대 크기는 **1,023G**입니다.||
|`disk.ramdisk.path`|**Ramdisk 경로** &ndash; 부팅 파티션(Ramdisk) 이미지의 경로입니다. Ramdisk 이미지는 시스템 이미지를 탑재하기 전에 커널에서 로드되는 시스템 이미지의 하위 집합입니다. Ramdisk 이미지에는 일반적으로 부팅 시 이진 파일 및 초기화 스크립트가 포함됩니다. 이 옵션을 지정하지 않으면 기본값은 에뮬레이터 시스템 디렉터리의 **ramdisk.img**입니다.||
|`disk.snapStorage.path`|**스냅샷 스토리지 경로** &ndash; 모든 스냅샷이 저장되는 스냅샷 스토리지 파일의 경로입니다. 실행 중에 만든 스냅샷은 모두 이 파일에 저장됩니다. 에뮬레이터를 실행하는 동안 이 파일에 저장된 스냅샷만 복원할 수 있습니다. 이 옵션을 지정하지 않으면 기본값은 에뮬레이터 데이터 디렉터리의 snapshots.img입니다.||
|`disk.systemPartition.initPath`|**시스템 파티션 초기 경로** &ndash; 시스템 이미지 파일의 읽기 전용 복사본의 경로입니다. 특히 시스템 라이브러리와 API 레벨 및 변형에 해당하는 데이터를 포함하는 파티션입니다. 이 경로를 지정하지 않으면 기본값은 에뮬레이터 시스템 디렉터리의 system.img입니다.||
|`disk.systemPartition.path`|**시스템 파티션 경로** &ndash; 읽기/쓰기 시스템 파티션 이미지의 경로입니다. 이 경로를 설정하지 않으면 `disk.systemPartition.initPath`로 지정된 파일의 내용에서 임시 파일이 만들어지고 초기화됩니다.||
|`disk.systemPartition.size`|**시스템 파티션 크기** &ndash; 이상적인 시스템 파티션 크기(바이트 단위)입니다. 실제 시스템 파티션 이미지가 이 설정보다 크면 해당 크기가 무시됩니다. 그렇지 않으면 시스템 파티션 파일이 커질 수 있는 최대 크기를 지정합니다. 이 값이 정수이면 크기를 바이트 단위로 지정합니다. 값에 **K**, **M** 또는 **G**를 추가하여 크기를 킬로바이트, 메가바이트 및 기가바이트 단위로 지정할 수도 있습니다. 최소 크기는 **9M**이고, 최대 크기는 **1,023G**입니다.||
|`hw.accelerometer`|**가속도계** &ndash; 에뮬레이트된 디바이스에 가속도계 센서가 포함되는지 여부를 결정합니다. 가속도계는 디바이스에서 방향을 결정하는 데 도움이 됩니다(자동 회전에 사용됨). 가속도계는 3개의 센서 축을 따라 디바이스의 가속도를 보고합니다.|yes, no|
|`hw.audioInput`|**오디오 녹음 지원** &ndash; 에뮬레이트된 디바이스에서 오디오를 녹음할 수 있는지 여부를 결정합니다.|yes, no|
|`hw.audioOutput`|**오디오 재생 지원** &ndash;에뮬레이트된 디바이스에서 오디오를 재생할 수 있는지 여부를 결정합니다.|yes, no|
|`hw.battery`|**배터리 지원** &ndash; 에뮬레이트된 디바이스가 배터리에서 실행될 수 있는지 여부를 결정합니다.|yes, no|
|`hw.camera`|**카메라 지원** &ndash; 에뮬레이트된 디바이스에 카메라가 있는지 여부를 결정합니다.|yes, no|
|`hw.camera.back`|**후면 카메라** &ndash; 후면 카메라(렌즈가 사용자 반대쪽으로 향함)를 구성합니다. 개발 컴퓨터에서 웹캠을 사용하여 에뮬레이트된 디바이스에서 후면 카메라를 시뮬레이션하는 경우 이 값은 webcam*n*으로 설정해야 합니다. 여기서 _n_은 웹캠을 선택합니다(웹캠 하나만 있는 경우 **webcam0** 선택). [emulated]로 설정하면 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션합니다. 후면 카메라를 사용하지 않도록 설정하려면 이 값을 [none]으로 설정합니다. 후면 카메라를 사용하도록 설정하면 `hw.camera`도 활성화해야 합니다.|emulated, none, webcam0|
|`hw.camera.front`|**전면 카메라** &ndash; 전면 카메라(렌즈가 사용자 쪽으로 향함)를 구성합니다. 개발 컴퓨터에서 웹캠을 사용하여 에뮬레이트된 디바이스에서 전면 카메라를 시뮬레이션하는 경우 이 값은 webcam*n*으로 설정해야 합니다. 여기서 _n_ 은 웹캠을 선택합니다(웹캠 하나만 있는 경우 **webcam0** 선택). [emulated]로 설정하면 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션합니다. 전면 카메라를 사용하지 않도록 설정하려면 이 값을 [none]으로 설정합니다. 전면 카메라를 사용하도록 설정하면 `hw.camera`도 활성화해야 합니다.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**최대 가로 카메라 픽셀** &ndash; 에뮬레이트된 디바이스의 카메라 최대 가로 해상도(픽셀 단위)를 구성합니다.||
|`hw.camera.maxVerticalPixels`|**최대 세로 카메라 픽셀** &ndash; 에뮬레이트된 디바이스의 카메라 최대 세로 해상도(픽셀 단위)를 구성합니다.||
|`hw.cpu.arch`|**CPU 아키텍처** &ndash; 가상 디바이스에서 에뮬레이트할 CPU 아키텍처입니다. 하드웨어 가속을 위해 Intel HAXM을 사용하는 경우 32비트 CPU에 대해 **x86**을 선택합니다. 64비트 HAXM 가속 디바이스의 경우 **x86_64**를 선택합니다. (SDK 관리자에서 해당 Intel x86 시스템 이미지(예: Intel x86 Atom 또는 Intel x86 Atom_64)를 설치해야 합니다.) ARM CPU를 시뮬레이션하려면 32비트에 대해 **arm**을 선택하거나 64비트 ARM CPU에 대해 **arm64**를 선택합니다. ARM 기반 가상 디바이스는 ARM에서 하드웨어 가속을 사용할 수 없으므로 x86 기반 가상 디바이스보다 훨씬 느리게 실행됩니다.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**CPU 모델** &ndash; 이 값은 일반적으로 설정되지 않은 상태로 유지됩니다(아직 명시적으로 설정되지 않은 경우 `hw.cpu.arch`에서 파생된 값으로 설정됨). 그러나 실험적 용도로 에뮬레이터 특정 문자열로 설정할 수 있습니다.||
|`hw.dPad`|**DPad 키** &ndash; 에뮬레이트된 디바이스에서 방향 패드(DPad) 키를 지원하는지 여부를 결정합니다. DPad에는 일반적으로 방향 제어를 나타내는 4개의 키가 있습니다.|yes, no|
|`hw.gps`|**GPS 지원** &ndash; 에뮬레이트된 디바이스에 GPS(글로벌 위치 시스템) 수신기가 있는지 여부를 결정합니다.|yes, no|
|`hw.gpu.enabled`|**GPU 에뮬레이션** &ndash; 에뮬레이트된 디바이스에서 GPU 에뮬레이션을 지원하는지 여부를 결정합니다. 사용하도록 설정되면 GPU 에뮬레이션에서 2D 및 3D 그래픽 모두를 화면에 렌더링하기 위해 OpenGL ES(Open GL for Embedded Systems)를 사용하며, 관련 GPU 에뮬레이션 모드 설정은 GPU 에뮬레이션을 구현하는 방법을 결정합니다.|yes, no|
|`hw.gpu.mode`|**GPU 에뮬레이션 모드** &ndash; 에뮬레이터에서 GPU 에뮬레이션을 구현하는 방법을 결정합니다. [auto]를 선택하면 에뮬레이터에서 개발 컴퓨터 설정에 따라 하드웨어 가속 및 소프트웨어 가속을 선택합니다. [host]를 선택하면 에뮬레이터에서 개발 컴퓨터의 그래픽 프로세서를 사용하여 더 빠른 렌더링을 위한 GPU 에뮬레이션을 수행합니다. GPU가 에뮬레이터와 호환되지 않고 Windows를 사용하는 경우 [host] 대신 [angle]을 시도할 수 있습니다. [angle] 모드는 DirectX를 사용하여 [host]와 비슷한 성능을 제공합니다. [mesa]를 선택하면 에뮬레이터에서 Mesa 3D 소프트웨어 라이브러리를 사용하여 그래픽을 렌더링합니다. 개발 컴퓨터의 그래픽 프로세서를 통해 렌더링하는 데 문제가 있으면 [mesa]를 선택합니다. [swiftshader] 모드는 컴퓨터의 GPU를 사용하는 것보다 약간 낮은 성능으로 소프트웨어에서 그래픽을 렌더링하는 데 사용할 수 있습니다. 사용되지 않는 [off] 옵션(그래픽 하드웨어 에뮬레이션 사용 안 함)은 일부 항목에 대해 부적절한 렌더링이 발생할 수 있으므로 사용하지 않는 것이 좋습니다.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**GSM 모뎀 지원** &ndash; 에뮬레이트된 디바이스에 GSM(이동 통신 글로벌 시스템) 전화 통신 무선 시스템을 지원하는 모뎀이 포함되는지 여부를 결정합니다.|yes, no|
|`hw.initialOrientation`|**초기 화면 방향** &ndash; 에뮬레이트된 디바이스의 화면 초기 방향(세로 또는 가로 모드)을 구성합니다. 세로 모드에서는 화면의 높이가 너비보다 큽니다. 가로 모드에서는 화면의 너비가 높이보다 큽니다. 디바이스 프로필에서 세로 및 가로 모드 모두를 지원하는 경우 에뮬레이트된 디바이스를 실행할 때 방향을 변경할 수 있습니다.|portrait, landscape|
|`hw.keyboard`|**키보드 지원** &ndash; 에뮬레이트된 디바이스에서 QWERTY 키보드를 지원하는지 여부를 결정합니다.|yes, no|
|`hw.keyboard.charmap`|**키보드 문자표 이름** &ndash; 이 디바이스의 하드웨어 문자표 이름입니다. 참고:  시스템 이미지를 적절하게 수정하지 않는 한 항상 기본값(**qwerty2**)이어야 합니다. 이 이름은 부팅 시 커널에 보내집니다. 잘못된 이름을 사용하면 사용할 수 없는 가상 디바이스가 됩니다.||
|`hw.keyboard.lid`|**키보드 덮개 지원**&ndash; 키보드 지원을 사용하도록 설정된 경우 이 설정은 QWERTY 키보드를 닫거나 숨길 수 있는지, 아니면 열거나 표시할 수 있는지 여부를 결정합니다. [hw.keyboard]가 [false]로 설정되면 이 설정은 무시됩니다. 참고: 에뮬레이트된 디바이스에서 API 레벨 12 이상을 대상으로 하는 경우 기본값은 [false]입니다.|yes, no|
|`hw.lcd.backlight`|**LCD 후광** &ndash; 에뮬레이트된 디바이스에서 LCD 후광을 시뮬레이션할지 여부를 결정합니다.|yes, no|
|`hw.lcd.density`|**LCD 밀도** &ndash; 에뮬레이트된 LCD 디스플레이의 밀도이며, 밀도 독립적 픽셀 또는 dp(가상 픽셀 단위)로 측정된 것입니다. 설정이 160dp이면 각 dp가 하나의 물리적 픽셀에 해당합니다. 런타임에 Android에서 이 값을 사용하여 올바른 디스플레이 렌더링에 적절한 리소스/자산을 선택하고 크기를 조정합니다.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**LCD 색 농도** &ndash; LCD 디스플레이를 구동하기 위한 비트맵을 보유하는 에뮬레이트된 프레임 버퍼의 색 비트 농도입니다. 이 값은 16비트(65,536개 색 가능) 또는 32비트(16,777,216개 색 + 투명도)일 수 있습니다. 32비트로 설정하면 에뮬레이터가 약간 느리게 실행되지만 색 정확도가 향상됩니다.|16, 32|
|`hw.lcd.height`|**LCD 픽셀 높이** &ndash; 에뮬레이트된 LCD 디스플레이의 수직 크기를 구성하는 픽셀 수입니다.||
|`hw.lcd.width`|**LCD 픽셀 너비** &ndash; 에뮬레이트된 LCD 디스플레이의 수평 크기를 구성하는 픽셀 수입니다.||
|`hw.mainKeys`|**하드웨어 뒤로/홈 키** &ndash; 에뮬레이트된 디바이스에서 하드웨어 뒤로 및 홈 탐색 단추를 지원하는지 여부를 결정합니다. 소프트웨어에서만 단추를 구현하더라도 이 값은 **yes**로 설정할 수 있습니다. `hw.mainKeys`가 **yes**로 설정되면 에뮬레이터에서 화면에 탐색 단추를 표시하지 않지만 에뮬레이터 측면 패널을 사용하여 이러한 단추를 “누를” 수 있습니다.|yes, no|
|`hw.ramSize`|**디바이스 RAM 크기**&ndash; 에뮬레이트된 디바이스의 실제 RAM 크기(메가바이트 단위)입니다. 기본값은 화면 크기 또는 스킨 버전에서 계산됩니다. 크기를 늘리면 에뮬레이터의 작동 속도가 빨라지지만 개발 컴퓨터에서 더 많은 리소스가 필요합니다.||
|`hw.screen`|**터치 스크린 형식** &ndash; 에뮬레이트된 디바이스의 화면 형식을 정의합니다. [multi-touch] 화면은 터치 인터페이스에서 둘 이상의 손가락을 추적할 수 있습니다. [touch] 화면은 하나의 손가락 터치 이벤트만 감지할 수 있습니다. [no-touch] 화면은 터치 이벤트를 감지하지 않습니다.|touch, multi-touch, no-touch|
|`hw.sdCard`|**SD 카드 지원** &ndash; 에뮬레이트된 디바이스에서 가상 SD(Secure Digital) 카드의 삽입 및 제거를 지원하는지 여부를 결정합니다. 에뮬레이터는 개발 컴퓨터에 저장된 탑재 가능한 디스크 이미지를 사용하여 실제 SD 카드 디바이스의 파티션을 시뮬레이션합니다(hw.sdCard.path 참조).|yes, no|
|`sdcard.size`|**SD 카드 크기** &ndash; `hw.sdCard.path`로 지정된 위치에 있는 가상 SD 카드 파일의 크기(바이트 단위)를 지정합니다. 이 값이 정수이면 크기를 바이트 단위로 지정합니다. 값에 **K**, **M** 또는 **G**를 추가하여 크기를 킬로바이트, 메가바이트 및 기가바이트 단위로 지정할 수도 있습니다. 최소 크기는 **9M**이고, 최대 크기는 **1,023G**입니다.||
|`hw.sdCard.path`|**SD 카드 이미지 경로** &ndash; 개발 컴퓨터에 있는 SD 카드 파티션 이미지 파일의 파일 이름과 경로를 지정합니다. 예를 들어 이 경로는 Windows에서 **C:\sd\sdcard.img**로 설정할 수 있습니다.||
|`hw.sensors.magnetic_field`|**자기장 센서** &ndash; 에뮬레이트된 디바이스에서 자기장 센서를 지원하는지 여부를 결정합니다. 자기장 센서(자기계라고도 함)는 3개의 센서 축을 따라 측정된 주위 지자기장을 보고합니다. 컴퍼스 읽기에 액세스해야 하는 앱의 경우 이 설정을 사용하도록 설정합니다. 예를 들어 내비게이션 앱은 이 센서를 사용하여 사용자가 지향하는 방향을 감지할 수 있습니다.|yes, no|
|`hw.sensors.orientation`|**방향 센서** &ndash; 에뮬레이트된 디바이스에서 방향 센서 값을 제공하는지 여부를 결정합니다. 방향 센서는 3개의 모든 물리적 축(x, y, z)을 중심으로 디바이스가 회전하는 각도를 측정합니다. Android 2.2(API 수준 8)부터는 방향 센서가 지원되지 않습니다.|yes, no|
|`hw.sensors.proximity`|**근접 센서** &ndash; 에뮬레이트된 디바이스에서 근접 센서를 지원하는지 여부를 결정합니다. 이 센서는 개체의 근접 거리를 디바이스의 보기 화면을 기준으로 측정합니다. 일반적으로 송수화기를 사람의 귀에 대고 있는지 여부를 확인하는 데 사용됩니다.|yes, no|
|`hw.sensors.temperature`|**온도 센서** &ndash; 에뮬레이트된 디바이스에서 온도 센서를 지원하는지 여부를 결정합니다. 이 센서는 디바이스의 온도를 섭씨 온도(&deg;C)로 측정합니다.|yes, no|
|`hw.touchScreen`|**터치 스크린 지원** &ndash; 에뮬레이트된 디바이스에서 터치 스크린을 지원하는지 여부를 결정합니다. 터치 스크린은 화면에서 개체를 직접 조작하는 데 사용됩니다.|yes, no|
|`hw.trackBall`|**트랙볼 지원** &ndash; 에뮬레이트된 디바이스에서 트랙볼을 지원하는지 여부를 결정합니다.|yes, no|
|`hw.useext4`|**EXT4 파일 시스템 지원** &ndash; 에뮬레이트된 디바이스에서 파티션에 대해 Linux EXT4 파일 시스템을 사용하는지 여부를 결정합니다. 이제 파일 시스템 형식이 자동으로 감지되므로 이 옵션은 더 이상 사용되지 않으며 무시됩니다.|no|
|`kernel.newDeviceNaming`|**커널 새 디바이스 이름 지정** &ndash; 커널에 새 디바이스 이름 지정 체계가 필요한지 여부를 지정하는 데 사용됩니다. 일반적으로 Linux 3.10 커널 이상에서 사용됩니다. **autodetect**로 설정하면 에뮬레이터에서 커널에 새 디바이스 이름 지정 체계가 필요한지 여부를 자동으로 감지합니다.|autodetect, yes, no|
|`kernel.parameters`|**커널 매개 변수** &ndash; Linux 커널 부팅 매개 변수의 문자열을 지정합니다. 이 설정은 기본적으로 비워 둡니다.||
|`kernel.path`|**커널 경로** &ndash; Linux 커널 경로를 지정합니다. 이 경로를 지정하지 않으면 에뮬레이터에서 에뮬레이터 시스템 디렉터리의 kernel-ranchu를 찾습니다.||
|`kernel.supportsYaffs2`|**YAFFS2 파티션 지원** &ndash; 커널에서 YAFFS2(Yet Another Flash File System 2) 파티션을 지원하는지 여부를 결정합니다. 일반적으로 Linux 3.10 이전의 커널에만 적용됩니다. **autodetect**로 설정하면 에뮬레이터에서 커널이 YAFFS2 파일 시스템을 탑재할 수 있는지 여부를 자동으로 감지합니다.|autodetect, yes, no|
|`skin.name`|**스킨 이름** &ndash; Android Emulator 스킨의 이름입니다. 스킨은 에뮬레이터 디스플레이의 시각적 개체 요소 및 컨트롤 요소를 정의하는 파일의 모음입니다. 개발 컴퓨터에 표시되는 AVD 창의 모양을 설명합니다. 스킨은 화면 크기, 단추 및 전체 디자인을 설명하지만 앱 작동에는 영향을 주지 않습니다.||
|`skin.path`|**스킨 경로** &ndash; skin.name에 지정된 에뮬레이터 스킨 파일이 포함된 디렉터리 경로입니다. 이 디렉터리에는 hardware.ini 레이아웃 파일 및 스킨의 표시 요소 이미지 파일이 포함되어 있습니다.||
|`skin.dynamic`|**동적 스킨** &ndash; 동적 스킨인지의 여부입니다. 에뮬레이터에서 지정된 너비와 높이에 따라 지정된 크기의 스킨을 생성하는 경우 에뮬레이터 스킨은 동적 스킨입니다.|no|
