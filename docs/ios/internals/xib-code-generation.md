---
title: Xamarin.ios의 xib 코드 생성
description: 이 문서에서는 xib 파일을에 C#매핑하는 xamarin.ios가 코드를 생성 하 여 프로그래밍 방식으로 시각적 컨트롤에 액세스할 수 있도록 하는 방법을 설명 합니다.
ms.prod: xamarin
ms.assetid: 365991A8-E07A-0420-D28E-BC4D32065E1A
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/21/2017
ms.openlocfilehash: 778b8eeb82ebfb62cfb8c16e14f341c9afb8ff7a
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73022249"
---
# <a name="xib-code-generation-in-xamarinios"></a>Xamarin.ios의 xib 코드 생성

> [!IMPORTANT]
> 이 문서에서는 작업 및 콘센트가 Xamarin Designer for iOS에서 사용 되지 않으므로 Xcode의 Interface Builder와의 통합 Mac용 Visual Studio 설명 합니다. IOS 디자이너에 대 한 자세한 내용은 [Ios designer](~/ios/user-interface/designer/index.md) 문서를 참조 하세요.

Apple Interface Builder 도구 ("IB")를 사용 하 여 사용자 인터페이스를 시각적으로 디자인할 수 있습니다. IB에서 만든 인터페이스 정의는 **xib** 파일에 저장 됩니다. **Xib** 파일의 widget 및 기타 개체에는 사용자 지정 사용자 정의 형식일 수 있는 "클래스 id"가 제공 될 수 있습니다. 이렇게 하면 위젯의 동작을 사용자 지정 하 고 사용자 지정 위젯을 작성할 수 있습니다.

이러한 사용자 클래스는 일반적으로 UI 컨트롤러 클래스의 서브 클래스입니다. 여기에는 인터페이스 개체에 연결할 수 있는 *콘센트* (속성에 해당) 및 *작업* (이벤트와 유사)이 있습니다. 런타임에 IB 파일이 로드 되 면 개체가 만들어지고, 해당 콘센트와 작업이 다양 한 UI 개체에 동적으로 연결 됩니다. 이러한 관리 되는 클래스를 정의할 때는 IB에서 예상 하는 것과 일치 하도록 모든 작업 및 콘센트를 정의 해야 합니다. Mac용 Visual Studio는 코드 숨김 모델을 사용 하 여이를 단순화 합니다. 이는 Xcode에 대해 수행 하는 작업과 비슷하지만, 코드 생성 모델 및 규칙이 .NET 개발자에 게 보다 친숙 한 조정 된 되었습니다.

**Xib** 파일에 대 한 작업은 현재 Visual Studio 용 xamarin.ios에서 지원 되지 않습니다.

## <a name="xib-files-and-custom-classes"></a>xib 파일 및 사용자 지정 클래스

Cocoa Touch에서 기존 유형을 사용 하는 것 외에도 **xib** 파일에 사용자 지정 형식을 정의할 수 있습니다. **Xib** 파일에 정의 되어 있거나 코드에 C# 만 정의 된 형식을 사용할 수도 있습니다. 현재는 Interface Builder **xib** 파일 외부에서 정의 된 형식의 세부 정보를 인식 하지 못하므로 사용자 지정 콘센트 및 작업을 표시 하거나 표시 하지 않습니다. 이러한 제한 제거는 나중에 계획 됩니다.

Interface Builder의 "클래스" 탭에서 "하위 클래스 추가" 명령을 사용 하 여 **xib** 파일에 사용자 지정 클래스를 정의할 수 있습니다. 이러한 클래스를 "CodeBehind" 클래스로 참조 합니다. **Xib** 파일에 프로젝트의 "xib.designer.cs" 해당 파일이 있는 경우 Mac용 Visual Studio는 **xib**의 모든 사용자 지정 클래스에 대 한 부분 클래스 정의를 자동으로 채웁니다. 이러한 partial 클래스는 "디자이너 클래스"로 지칭 됩니다.

## <a name="generating-code"></a>코드 생성

Xib *파일의 빌드*작업을 사용 하는 **{0}경우 xib.designer.cs** 파일이 Mac용 Visual Studio 프로젝트에도 있는 경우에는 디자이너 파일의 일부 클래스가 디자이너 파일에 생성 되어 다음에서 찾을 수 있는 모든 사용자 클래스에 대해 **{0}** **xib** 파일입니다 .이 파일에는 모든 동작에 대 한 콘센트 및 부분 메서드에 대 한 속성이 있습니다. 코드 생성은이 파일이 있는 경우에만 사용할 수 있습니다.

Xib 파일이 변경 되 고 포커스를 Mac용 Visual Studio 다시 얻으면 디자이너 파일이 자동으로 업데이트 됩니다 **.** 다음에 Mac용 Visual Studio 파일을 업데이트할 때 변경 내용을 덮어쓰기 때문에 디자이너 파일을 수동으로 수정 하면 안 됩니다.

## <a name="registration-and-namespaces"></a>등록 및 네임 스페이스

Mac용 Visual Studio은 디자이너 파일 위치에 대 한 프로젝트의 기본 네임 스페이스를 사용 하 여 디자이너 클래스를 생성 하 여 일반 .NET 프로젝트 namespacing와 일치 하도록 합니다. 디자이너 파일의 네임 스페이스는 프로젝트의 "기본 네임 스페이스" 및 ".NET 명명 정책" 설정에 따라 결정 됩니다. 프로젝트의 기본 네임 스페이스가 변경 되는 경우 MD는 새 네임 스페이스의 클래스를 다시 생성 하므로 partial 클래스가 더 이상 일치 하지 않는 것을 알 수 있습니다.

클래스를 목표-C 런타임에서 검색할 수 있도록 하려면 Mac용 Visual Studio `[Register (name)]` 특성을 클래스에 적용 합니다. Xamarin.ios는 `NSObject`파생 클래스를 자동으로 등록 하지만 정규화 된 .NET 이름을 사용 합니다. Mac용 Visual Studio에서 적용 하는 특성은이를 재정의 하 여 각 클래스가 **xib** 파일에 사용 된 이름으로 등록 되도록 합니다. Mac용 Visual Studio를 사용 하 여 디자이너 파일을 생성 하지 않고 IB에서 사용자 지정 클래스를 사용 하는 경우 관리 되는 클래스가 예상 목표-C 클래스 이름과 일치 하도록 수동으로이를 적용 해야 할 수 있습니다.

클래스는 둘 이상의 **xib**에서 정의 될 수 없으며 충돌 합니다.

## <a name="non-designer-class-parts"></a>비 디자이너 클래스 파트

디자이너 partial 클래스는 있는 그대로 사용 하기 위한 것이 아닙니다. 콘센트가 전용 이며 기본 클래스를 지정 하지 않았습니다. 각 클래스는 다른 파일에 해당 하는 "비 디자이너" 클래스 부분을 포함할 것으로 예상 됩니다 .이 클래스는 기본 클래스를 설정 하 고,이를 사용 하거나 노출 하 고, xib를 로드할 때 네이티브 코드에서 클래스를 인스턴스화하는 데 필요한 생성자를 정의 **합니다.** . **Xib** 템플릿에서는이 작업을 수행 하지만 **xib**에서 정의 하는 추가 사용자 지정 클래스의 경우에는 디자이너가 아닌 파트를 수동으로 추가 해야 합니다.

이는 유연성이 필요한 이유입니다. 예를 들어, 여러 CodeBehind 클래스가 IB에서 서브클래싱된 클래스를 서브클래싱하는 공용 관리 되는 추상 클래스를 서브 클래스로 만들 수 있습니다.

Xib.designer.cs 디자이너 파일 **{0}** 옆에 있는 **xib.cs 파일{0}** 에 이러한 파일을 저장 하는 것이 일반적입니다.

<a name="generated" />

## <a name="generated-actions-and-outlets"></a>생성 된 작업 및 콘센트

부분 디자이너 클래스에서 Mac용 Visual Studio는 IB에 정의 된 연결 된 모든 콘센트에 해당 하는 속성과 연결 된 작업에 해당 하는 부분 메서드를 생성 합니다.

### <a name="outlet-properties"></a>유출 속성

디자이너 클래스는 사용자 지정 클래스에 정의 된 모든 콘센트에 해당 하는 속성을 포함 합니다. 이러한 속성은 지연 바인딩을 사용 하도록 설정 하기 위해 Xamarin.ios에서 목표로 하는 C 브리지의 구현 세부 정보입니다. Private 필드와 동일한 것으로 간주 해야 합니다 .이는 CodeBehind 클래스 에서만 사용할 수 있습니다. 이러한 클래스를 공용으로 설정 하려는 경우 다른 전용 필드와 마찬가지로 비 디자이너 클래스 부분에 접근자 속성을 추가 합니다.

`id` 형식을 사용 하도록 콘센트 속성을 정의 하는 경우 (`NSObject`와 동일) 디자이너 코드 생성기는 현재 해당 콘센트에 연결 된 개체를 기반으로 가능한 가장 강력한 형식을 결정 합니다. 편의상이를 사용 하면 편리 합니다.
그러나이는 이후 버전에서 지원 되지 않을 수 있으므로 사용자 지정 클래스를 정의할 때 콘센트를 명시적으로 강력한 형식으로 지정 하는 것이 좋습니다.

### <a name="action-properties"></a>작업 속성

디자이너 클래스에는 사용자 지정 클래스에 정의 된 모든 작업에 해당 하는 부분 메서드가 포함 됩니다. 이러한 메서드는 구현이 없는 메서드입니다. 부분 메서드 (partial method)의 목적은 두 가지입니다.

1. 비 디자이너 클래스 부분의 클래스 본문에 `partial` Mac용 Visual Studio를 입력 하면에서 구현 되지 않은 모든 부분 메서드의 시그니처를 자동 완성 하는가 제공 됩니다.
2. 부분 메서드 시그니처에서는를 목표 C 세계에 노출 하는 특성을 적용 하 여 해당 작업으로 처리 될 수 있도록 합니다.

원하는 경우 부분 메서드를 무시 하 고 특성을 다른 메서드에 적용 하거나 기본 클래스로 이동 하 여 동작을 구현할 수 있습니다.

작업에 보낸 사람 형식이 `id`으로 정의 된 경우 (`NSObject`와 동일) 디자이너 코드 생성기는 현재 해당 작업에 연결 된 개체를 기반으로 가능한 가장 강력한 형식을 결정 합니다. 그러나이는 이후 버전에서 지원 되지 않을 수 있으므로 사용자 지정 클래스를 정의할 때 명시적으로 작업을 강력한 형식으로 지정 하는 것이 좋습니다.

이러한 부분 메서드는에 C#대해서만 생성 됩니다. CodeDOM은 부분 메서드를 지원 하지 않으므로 다른 언어에 대해서는 생성 되지 않습니다.

## <a name="cross-xib-class-usage"></a>크로스 XIB 클래스 사용

경우에 따라 사용자가 탭 컨트롤러와 같이 여러 **xib** 파일에서 동일한 클래스를 참조 하려고 합니다. **Xib** 파일에서 클래스 정의를 참조 하거나 두 번째 **. xib**에 동일한 클래스 이름을 다시 정의 하 여 명시적으로를 수행할 수 있습니다.

후자는 Mac용 Visual Studio xib 파일을 개별적으로 처리 하기 때문에 문제가 될 수 있습니다 **.** 중복 정의를 자동으로 검색 하 고 병합할 수 없으므로 동일한 partial 클래스가 여러 디자이너 파일에 정의 되어 있는 경우 레지스터 특성을 여러 번 적용 하면 충돌이 발생할 수 있습니다. 최신 버전의 Mac용 Visual Studio이 문제를 해결 하려고 시도 하지만 항상 예상 대로 작동 하지 않을 수 있습니다. 나중에이는 지원 되지 않을 수 있으며, Mac용 Visual Studio 대신 모든 **xib** 파일 및 프로젝트의 관리 코드에 정의 된 모든 형식을 **xib** 파일에서 직접 볼 수 있도록 합니다.

## <a name="type-resolution"></a>형식 확인

IB에 사용 되는 형식은 목표-C 형식 이름입니다. 이러한 속성은 Register 특성을 사용 하 여 CLR 형식에 매핑됩니다. 콘센트 및 작업 코드를 생성 하는 경우 Mac용 Visual Studio는 Xamarin.ios 코어로 래핑된 모든 목표 C 형식에 대 한 해당 CLR 형식을 확인 하 고 해당 형식 이름을 정규화 합니다.

그러나 코드 생성기는 현재 사용자 코드 또는 라이브러리의 목적-C 형식 이름에서 CLR 형식을 확인할 수 없으므로이 경우에는 형식 이름에 약어를 출력 합니다. 즉, 해당 CLR 형식은 목표-C 형식과 같은 이름을 사용 해야 하며이를 사용 하는 코드와 동일한 네임 스페이스에 있어야 합니다. 이는 코드를 생성 하는 동안 프로젝트의 모든 목표-C 형식을 고려 하 여 나중에 수정 될 예정입니다.
